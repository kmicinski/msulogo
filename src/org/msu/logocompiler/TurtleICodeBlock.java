package org.msu.logocompiler;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

/*
 * A representation of a code block for intermediate code generated by the compiler.
 * This is an indivisible block of code which executes from beginning to end, and 
 * cannot be interrupted.  This is sometimes called a ``basic block.''
 *
 * This is an implementation which merges between contiguous lists of instructions 
 * in linear time:  I was not able to find standard Java containers which offered 
 * this time complexity constraint.  However, because we won't be using the more 
 * advanced features of the Java containers, we don't really need anything more 
 * than what's implemented here.
 */
public class TurtleICodeBlock {
	private TurtleICodeInstruction firstInstruction = null;
	private TurtleICodeNonbranchingInstruction lastInstruction = null;
	
	/**
	 * Initialize this block with a nonbranching instruction.
	 * @param i A nonbranching instruction which will serve as the first 
	 * instruction in this block.
	 */
	public TurtleICodeBlock(TurtleICodeNonbranchingInstruction i)
	{
		firstInstruction = i;
		lastInstruction = i;
	}
	
	public TurtleICodeInstruction getFirstInsruction()
	{
		return firstInstruction;
	}
	
	public void setFirstInstruction(TurtleICodeInstruction i)
	{
		firstInstruction = i;
	}
	
	public TurtleICodeNonbranchingInstruction getLastInstruction()
	{
		return lastInstruction;
	}
	
	public void setLastInstruction(TurtleICodeNonbranchingInstruction i)
	{
		lastInstruction = i;
	}
	
	/**
	 * Add a nonterminating instruction to this block of instructions.
	 * @param i An instruction which will continue this nonbranching block. 
	 * @throws BlockContainsTerminatingInstructionException 
	 */
	public void addInstruction(TurtleICodeNonbranchingInstruction i) throws BlockContainsTerminatingInstructionException
	{
		if (isBlockTerminated())
		{
			throw new BlockContainsTerminatingInstructionException();
		}

		// Nothing here to begin with
		if (firstInstruction == null)
		{
			firstInstruction = i;
			lastInstruction = i;
			return;
		}
		// Something here, add it to the current list
		lastInstruction.setNextInstruction(i);
		lastInstruction = i;
	}
	
	/**
	 * 
	 * @param i
	 */
	public void addTerminatingInstruction(TurtleICodeInstruction i)
	{
		lastInstruction.setNextInstruction(i);
	}
	
	/**
	 * Is this block currently ended with a terminating expression.
	 * @return
	 */
	public boolean isBlockTerminated() 
	{
		return (lastInstruction != null 
				&& lastInstruction.getNextInstruction() != null);
	}
	
	/**
	 * We can take two sets of instructions and merge them together
	 * @param block
	 * @throws BlockContainsTerminatingInstructionException 
	 */	// 
	public void spliceNonbranchingBlock(TurtleICodeBlock block) 
		throws BlockContainsTerminatingInstructionException 
	{
		// If this block is currently terminated then we should throw an error: 
		// we can't continue adding instructions to a block which is already 
		// completed.
		if (isBlockTerminated())
		{
			throw new BlockContainsTerminatingInstructionException();
		}
		
		// Make the next instruction of the last instruction in this block the 
		// first instruction in the next block.
		lastInstruction.setNextInstruction(block.getFirstInsruction());
		
		// We have to consider one special case: what if the next block is 
		// a single branching instruction?  In this case there will be a 
		// first instruction in the block, but there won't be a last instruction
		// (i.e., the last instruction pointer of the blockw will be set to null).
		// If this is the case, we just leave the lastInstruction pointer where 
		// it currently is.
		if (block.getLastInstruction() != null)
		{
			lastInstruction = block.getLastInstruction();			
		}
		
		return;
	}
	
	public class BlockContainsTerminatingInstructionException extends Exception
	{

		/**
		 * 
		 */
		private static final long serialVersionUID = -489420517299240355L;
		
	}
}